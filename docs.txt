Entities:
negamax.py: module that holds the AlphaBeta agent logic
imports: (this means that the classes from bagchal.py are used here!)
from bagchal import *

1) TimeoutError: inherits from Exception
  - Custom Exception raised when allotted time for making the move has elapsed
2) AlphaBeta:
  - The alpha beta agent
  - Data Members:
    - no_of_nodes: No of nodes explored during the search
    - start_time, time_limit: for tracking thinking time
    - window: the length of the aspiration window
    - contempt: substitution for draw score (to discourage move repetition)
    - killers: hash table storing "killer" moves
    - tree_history: list of states reached from the root during the current line of play
    - transposition_table: stores previously encountered positions, their evaluations and the best move if found

  - Functions:
    - get_best_move(): finds the best move from the given game_state within the specified time limit
    - negamax(): the core negamax logic (Note: negamax is just a more efficient implementation of the alpha beta algorithm)
    - pick_move(): picks the highest priority move from the given set of legal moves
    - record_hash(): helper function for storing an entry in the transposition_table
    - tt_get(): helper function that retrieves a transposition_table entry
    - qsearch(): quiescence search for more robust leaf evaluations
    - evaluate(): returns the static evaluations of the given position

mcts.py: module that holds the MCTS agent logic
from bagchal import *

1) Node:
  - represents a node in the game tree
  - Data Members:
    - parent: the immediate parent
    - move: the move played from parent to reach the node
    - player_to_move: player to move from this node
    - unexpanded_move: list of moves yet to be played from this node
    - children: list of child nodes
    - visit_count: the no of times this node has been visited during MCTS simulations
    - total_value: the cumulative "reward" expected at this node gathered over many MCTS simulations

2) MCTS:
  - implementation of MCTS algorithm
  - Data Members:
    - rollout_epsilon: the probability with which moves must be selected randomly during rollouts
    - rollout_depth: the cutoff point for the rollout

  - Functions
    - search(): central logic for performing MCTS iterations
    - get_best_move(): returns the best move as determined by the MCTS algorithm from the given game state
    - tree_policy(): traverses the tree based on the UCT evaluation of nodes and selects an unexpanded node (Selection + Expansion)
    - rollout_poilicy(): policy for selecting the next move to play during rollout of a leaf node
    - rollout(): performs a rollout from the leaf node based on the rollout_poilicy (Rollout)
    - backpropagate(): backpropagates the result of the rollout from the newly expanded node along the line of play from the root node
    - evaluate_state(): returns the static evaluations of the given position

bagchal.py: module the holds the core bagchal logic
1) BitboardGameState:
  - The bitboard representation of the bagchal game_state
  - Data Members:
    - tigers_bb: 64-bit integer representing the positions of tigers on the board
    - goats_bb: 64-bit integer representing the positions of goats on the board
    - turn: the player to move
    - goats_to_place: remaining no of goats to be placed on the board
    - zob_hash: the zobrist hash key for the game state

  - Functions:
    - key(): getter for the zobrist hash
    - get_result(): returns the winner player or None if the game is still in play
    - is_game_over(): returns true if the game has ended else false
    - trapped_tiger_count(): the no of tigers trapped on the board.
    - get_legal_moves(): returns a list of legal moves possible from the game_state
    - make_move(): makes the passed move
    - unmake_move(): unmakes the last move on the stack

game.py: module that holds the UI
imports:
from bagchal import *
from mcts import MCTS

1) UIState:
  - An Enum representing the various states that the application can be in
    MAIN_MENU = "main_menu"
    MODE_SELECT = "mode_select"
    PLAYING_PVP = "playing_pvp"
    PLAYING_PVC_GOAT = "playing_pvc_goat"
    PLAYING_PVC_TIGER = "playing_pvc_tiger"
    PLAYING_CVC = "playing_cvc"
    GAME_OVER = "game_over"
    EXITING = "exiting"

2) Game: the central class that is responsible for managing UI state transitions and rendering the game board. it is modeled as a Finite State Machine
  - Data Members:
    - game_state: the current game state
    - cell_size: the size of the cells in the game grid
    - current_state: the current UI state
    - minimax_agent: an instance of the Alpha Beta agent
    - mcts_agent: an instance of the MCTS agent

  - Functions:
    - run(): the entry point
    - reset_game(): resets the game to the initial state
    - handle_events(): responsible for making transitions between different UI states based on user input
    - update_ai_logic(): handler for AI moves
    - place_piece(): place/ move a piece via user interaction
    - render_main_menu(): renders the main menu
    - render_mode_select(): renders the mode select menu
    - render_game(): renders the game board
    - render_game_over(): renders the game over screen
    - update(): core update logic
